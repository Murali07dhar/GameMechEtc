<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detective Evidence Board</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; background: #f0e68c; }
        #board { position: relative; width: 100vw; height: 100vh; background: url('https://via.placeholder.com/1920x1080?text=Corkboard') repeat; overflow: hidden; }
        .note { position: absolute; width: 150px; height: 150px; background: #ffff99; border: 1px solid #ccc; padding: 10px; cursor: move; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); }
        .note textarea { width: 100%; height: 100%; border: none; background: transparent; resize: none; }
        .image { position: absolute; width: 150px; height: auto; cursor: move; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); border: 2px solid red; }
        #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #toolbar { position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px; }
        button { margin-right: 5px; }
        #user-info { position: fixed; top: 10px; right: 10px; background: rgba(255,255,255,0.8); padding: 5px; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="board">
        <canvas id="canvas"></canvas>
    </div>
    <div id="toolbar">
        <button onclick="addNote()">Add Note</button>
        <input type="file" id="imageUpload" accept="image/*" style="display: none;" onchange="handleFileSelect(event)">
        <button onclick="document.getElementById('imageUpload').click()">Add Image</button>
        <button onclick="startConnecting()">Connect Items</button>
        <button onclick="startDeleting()">Delete Item</button>
    </div>
    <div id="user-info">Connecting...</div>

    <script type="module">
        // --- Firebase v11.6.1 Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, deleteDoc, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // --- GLOBAL STATE ---
        let app, auth, db, storage, itemsCol, connectionsCol;
        let unsubscribeItems = () => {}, unsubscribeConnections = () => {};
        const userInfo = document.getElementById('user-info');
        let items = {}; // Local cache {id: data}
        let connections = []; // Array of {from, to, id}
        let isConnecting = false;
        let connectFrom = null;
        let isDeleting = false;
        let selectedForDelete = null;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- FIREBASE INITIALIZATION & AUTH ---
        async function main() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'collaborative-board-default';
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { 
                apiKey: "YOUR_API_KEY", 
                authDomain: "YOUR_AUTH_DOMAIN", 
                projectId: "YOUR_PROJECT_ID",
                storageBucket: "YOUR_STORAGE_BUCKET",
                messagingSenderId: "YOUR_SENDER_ID",
                appId: "YOUR_APP_ID"
            };
            
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                storage = getStorage(app);
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                if(userInfo) userInfo.textContent = "Error connecting to services.";
                return;
            }

            onAuthStateChanged(auth, user => {
                if (user) {
                    if(userInfo) userInfo.textContent = `User ID: ${user.uid}`;
                    itemsCol = collection(db, `artifacts/${appId}/public/data/items`);
                    connectionsCol = collection(db, `artifacts/${appId}/public/data/connections`);
                    setupSnapshotListeners();
                } else {
                    if(userInfo) userInfo.textContent = 'Not authenticated.';
                    unsubscribeItems();
                    unsubscribeConnections();
                }
            });

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
                if(userInfo) userInfo.textContent = 'Authentication Error!';
            }
        }

        // --- SNAPSHOT LISTENERS ---
        function setupSnapshotListeners() {
            unsubscribeItems();
            unsubscribeConnections();

            unsubscribeItems = onSnapshot(itemsCol, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added" || change.type === "modified") {
                        items[change.doc.id] = change.doc.data();
                    }
                    if (change.type === "removed") {
                        delete items[change.doc.id];
                    }
                });
                renderItems();
                drawConnections();
            }, (error) => {
                console.error("Items snapshot error:", error);
                if(userInfo) userInfo.textContent = "Error loading data.";
            });

            unsubscribeConnections = onSnapshot(connectionsCol, (snapshot) => {
                connections = [];
                snapshot.forEach((doc) => {
                    connections.push({ id: doc.id, ...doc.data() });
                });
                drawConnections();
            }, (error) => {
                console.error("Connections snapshot error:", error);
            });
        }

        // --- ITEM OPERATIONS ---
        async function deleteItem(itemId, itemData) {
            if (!itemsCol) {
                console.error("Firestore collection not initialized.");
                return;
            }
            if (!itemData) {
                console.error("Item data is required to delete.");
                return;
            }

            if (itemData.type === 'image' && itemData.src) {
                try {
                    const imageRef = ref(storage, itemData.src);
                    await deleteObject(imageRef);
                    console.log("Image deleted from Storage.");
                } catch (error) {
                    if (error.code !== 'storage/object-not-found') {
                        console.error("Error deleting image from storage:", error);
                    }
                }
            }
            
            await deleteDoc(doc(itemsCol, itemId));
            console.log("Item deleted from Firestore.");
        }

        async function handleImageUpload(file, position) {
            if (!itemsCol || !auth.currentUser) {
                console.error("Cannot upload image: User not authenticated or DB not ready.");
                return;
            }
            const { x, y } = position;
            const userId = auth.currentUser.uid;

            const newDocRef = await addDoc(itemsCol, {
                type: 'image', status: 'uploading',
                x, y, width: 150, height: 150,
                rotation: Math.random() * 4 - 2, zIndex: 1,
                owner: userId
            });

            const filePath = `images/${userId}/${newDocRef.id}/${file.name}`;
            const storageRef = ref(storage, filePath);
            const uploadTask = uploadBytesResumable(storageRef, file);

            uploadTask.on('state_changed', 
                (snapshot) => {
                    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                    console.log('Upload is ' + progress + '% done');
                },
                (error) => {
                    console.error("Upload failed:", error);
                    deleteDoc(newDocRef);
                },
                async () => {
                    const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                    await updateDoc(newDocRef, {
                        status: 'complete',
                        src: downloadURL
                    });
                    console.log("Image upload complete, URL:", downloadURL);
                }
            );
        }

        // --- BOARD FUNCTIONS ---
        async function addNote() {
            if (!itemsCol || !auth.currentUser) return;
            const userId = auth.currentUser.uid;
            await addDoc(itemsCol, {
                type: 'note', content: 'Edit me',
                x: 100, y: 100, width: 150, height: 150,
                rotation: 0, zIndex: 1, owner: userId
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleImageUpload(file, { x: 100, y: 100 });
            }
        }

        function renderItems() {
            document.querySelectorAll('.note, .image').forEach(el => el.remove());
            Object.entries(items).forEach(([id, item]) => {
                if (item.status === 'uploading') return; // Skip rendering uploading placeholders

                const el = document.createElement('div');
                el.id = id;
                el.style.left = `${item.x}px`;
                el.style.top = `${item.y}px`;
                el.style.width = `${item.width}px`;
                el.style.height = `${item.height}px`;
                el.style.transform = `rotate(${item.rotation}deg)`;
                el.style.zIndex = item.zIndex;
                el.setAttribute('draggable', true);
                el.addEventListener('dragstart', dragStart);
                el.addEventListener('dragend', dragEnd);
                el.addEventListener('click', () => {
                    if (isConnecting) handleConnect(id);
                    if (isDeleting) handleDelete(id);
                });

                if (item.type === 'note') {
                    el.className = 'note';
                    const textarea = document.createElement('textarea');
                    textarea.value = item.content;
                    textarea.onchange = async () => {
                        await updateDoc(doc(itemsCol, id), { content: textarea.value });
                    };
                    el.appendChild(textarea);
                } else if (item.type === 'image' && item.src) {
                    el.className = 'image';
                    const img = document.createElement('img');
                    img.src = item.src;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    el.appendChild(img);
                }

                document.getElementById('board').appendChild(el);
            });
        }

        function dragStart(e) {
            e.dataTransfer.setData('text', e.target.id);
        }

        async function dragEnd(e) {
            const id = e.target.id;
            const el = document.getElementById(id);
            const newX = e.clientX - el.offsetWidth / 2;
            const newY = e.clientY - el.offsetHeight / 2;
            el.style.left = `${newX}px`;
            el.style.top = `${newY}px`;
            await updateDoc(doc(itemsCol, id), { x: newX, y: newY });
            drawConnections();
        }

        document.getElementById('board').addEventListener('dragover', e => e.preventDefault());
        document.getElementById('board').addEventListener('drop', e => e.preventDefault());

        function startConnecting() {
            isConnecting = !isConnecting;
            isDeleting = false;
            connectFrom = null;
            alert(isConnecting ? 'Click first item to connect from, then to' : 'Connecting mode off');
        }

        async function handleConnect(id) {
            if (!connectFrom) {
                connectFrom = id;
            } else {
                await addDoc(connectionsCol, { from: connectFrom, to: id });
                connectFrom = null;
            }
        }

        function startDeleting() {
            isDeleting = !isDeleting;
            isConnecting = false;
            selectedForDelete = null;
            alert(isDeleting ? 'Click an item to delete' : 'Delete mode off');
        }

        async function handleDelete(id) {
            const itemData = items[id];
            if (itemData) {
                if (confirm('Delete this item?')) {
                    await deleteItem(id, itemData);
                }
            }
            isDeleting = false;
        }

        function drawConnections() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            connections.forEach(conn => {
                const from = document.getElementById(conn.from);
                const to = document.getElementById(conn.to);
                if (from && to) {
                    ctx.beginPath();
                    ctx.moveTo(from.offsetLeft + from.offsetWidth / 2, from.offsetTop + from.offsetHeight / 2);
                    ctx.lineTo(to.offsetLeft + to.offsetWidth / 2, to.offsetTop + to.offsetHeight / 2);
                    ctx.stroke();
                }
            });
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawConnections();
        });

        // --- INITIALIZE APP ---
        main();
    </script>
</body>
</html>
