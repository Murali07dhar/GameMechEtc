<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Detective Evidence Board</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the evidence board */
        body {
            font-family: 'Special Elite', monospace;
            background-color: #1a1a1a;
        }
        #evidence-board {
            background-image: url('https://www.transparenttextures.com/patterns/cork-wallet.png');
            background-color: #6B4F3A;
            width: 100%;
            height: 90vh;
            position: relative;
            overflow: hidden;
            border: 12px solid #3a2d22;
            border-radius: 4px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7), inset 0 0 15px rgba(0,0,0,0.5);
        }
        .note {
            position: absolute;
            width: 220px;
            height: 180px;
            background-color: #fdf9e0;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.4);
            padding: 20px 15px 15px 15px;
            cursor: move;
            display: flex;
            flex-direction: column;
            border-radius: 2px;
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
            z-index: 5;
        }
        .note.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
            z-index: 20 !important;
        }
        .note::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, #ff5252, #c62828);
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            z-index: 1;
        }
        .note:hover {
            transform: scale(1.05) rotate(0deg) !important;
            z-index: 10;
        }
        .note textarea {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            resize: none;
            outline: none;
            font-family: inherit;
            font-size: 16px;
            color: #333;
        }
        .note .delete-btn, .note .connect-btn {
            position: absolute;
            top: -12px;
            right: -12px;
            background: #ef4444;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            z-index: 2;
        }
        .note:hover .delete-btn, .note:hover .connect-btn {
            display: flex;
        }
        .note .connect-btn {
            right: 18px;
            background: #3b82f6;
        }
        .note-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 2px;
        }
        #connector-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .loading {
            color: #fbbf24;
        }
        .error {
            color: #ef4444;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <h1 class="text-5xl text-gray-200 font-bold mb-4 tracking-widest text-shadow-lg">CLASSIFIED</h1>
    <div class="mb-4 flex items-center gap-6">
        <button id="add-note-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition-transform transform hover:scale-105 cursor-grab">
            Add Evidence (Drag Me)
        </button>
        <span class="text-gray-300">USER ID: <strong id="user-id-display" class="text-yellow-400 tracking-wider">Loading...</strong></span>
        <span id="connection-status" class="text-gray-300">Status: <span class="loading">Connecting...</span></span>
    </div>
    <div id="evidence-board" class="w-full">
        <canvas id="connector-canvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = typeof window.__firebase_config !== 'undefined' ? 
            JSON.parse(window.__firebase_config) : 
            {
                apiKey: "demo-key",
                authDomain: "demo-project.firebaseapp.com",
                projectId: "demo-project"
            };
        
        const appId = typeof window.__app_id !== 'undefined' ? window.__app_id : 'default-evidence-board';

        let app, db, auth;
        let userId = null;
        let notesCollection, connectionsCollection;
        let unsubscribeNotes, unsubscribeConnections;

        // --- Initialize Firebase ---
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            updateStatus('Initializing...', 'loading');
        } catch (error) {
            console.error("Firebase initialization error:", error);
            updateStatus('Connection Failed', 'error');
        }

        function updateStatus(message, type = '') {
            const statusEl = document.getElementById('connection-status');
            const statusSpan = statusEl.querySelector('span');
            statusSpan.textContent = message;
            statusSpan.className = type;
        }

        // --- Authentication ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                document.getElementById('user-id-display').textContent = userId.substring(0, 8) + '...';
                
                notesCollection = collection(db, `artifacts/${appId}/public/data/notes`);
                connectionsCollection = collection(db, `artifacts/${appId}/public/data/connections`);
                
                updateStatus('Connected', 'text-green-400');
                initializeBoard();
            } else {
                try {
                    updateStatus('Authenticating...', 'loading');
                    if (typeof window.__initial_auth_token !== 'undefined') {
                        await signInWithCustomToken(auth, window.__initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Authentication Error:", error);
                    updateStatus('Auth Failed', 'error');
                }
            }
        });

        const board = document.getElementById('evidence-board');
        const addNoteBtn = document.getElementById('add-note-btn');
        const canvas = document.getElementById('connector-canvas');
        const ctx = canvas.getContext('2d');
        
        let isDragging = false;
        let activeNote = null;
        let offsetX, offsetY;
        let isConnecting = false;
        let startConnectionNodeId = null;
        let notes = new Map();
        let connections = new Map();

        // --- Board and Canvas Sizing ---
        function resizeCanvas() {
            const rect = board.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            drawAllConnections();
        }
        
        window.addEventListener('resize', debounce(resizeCanvas, 100));
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // --- Note Creation ---
        async function createNoteElement(noteData) {
            const noteEl = document.createElement('div');
            noteEl.className = 'note';
            noteEl.id = noteData.id;
            
            // Ensure position is within board bounds
            const maxX = board.clientWidth - 220;
            const maxY = board.clientHeight - 180;
            const x = Math.max(0, Math.min(noteData.x || 50, maxX));
            const y = Math.max(0, Math.min(noteData.y || 50, maxY));
            
            noteEl.style.left = `${x}px`;
            noteEl.style.top = `${y}px`;
            
            const rotation = noteData.rotation || (Math.random() * 8 - 4);
            noteEl.style.transform = `rotate(${rotation}deg)`;
            
            if (!noteData.rotation && userId) {
                try {
                    await setDoc(doc(notesCollection, noteData.id), { rotation }, { merge: true });
                } catch (error) {
                    console.error("Error updating rotation:", error);
                }
            }

            if (noteData.type === 'text') {
                const textarea = document.createElement('textarea');
                textarea.value = noteData.content || '';
                textarea.placeholder = "Jot down a clue...";
                textarea.addEventListener('input', debounce((e) => {
                    updateNoteContent(noteData.id, e.target.value);
                }, 300));
                noteEl.appendChild(textarea);
            } else if (noteData.type === 'image') {
                const img = document.createElement('img');
                img.src = noteData.content;
                img.className = 'note-image';
                img.onerror = () => {
                    img.alt = 'Failed to load image';
                    img.style.background = '#f3f4f6';
                };
                noteEl.appendChild(img);
            }

            const deleteBtn = document.createElement('button');
            deleteBtn.innerHTML = '&times;';
            deleteBtn.className = 'delete-btn';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                deleteNote(noteData.id);
            };
            noteEl.appendChild(deleteBtn);
            
            const connectBtn = document.createElement('button');
            connectBtn.innerHTML = '&#128279;';
            connectBtn.className = 'connect-btn';
            connectBtn.onclick = (e) => {
                e.stopPropagation();
                startConnection(noteData.id);
            };
            noteEl.appendChild(connectBtn);

            noteEl.addEventListener('mousedown', startDrag);
            noteEl.addEventListener('click', handleNoteClick);

            return noteEl;
        }
        
        // --- Note Selection Logic ---
        function selectNote(noteElement) {
            const currentlySelected = document.querySelector('.note.selected');
            if (currentlySelected) {
                currentlySelected.classList.remove('selected');
            }
            if (noteElement) {
                noteElement.classList.add('selected');
            }
        }

        board.addEventListener('click', (e) => {
            if (e.target === board || e.target === canvas) {
                selectNote(null);
                if (isConnecting) {
                    isConnecting = false;
                    startConnectionNodeId = null;
                    board.style.cursor = 'default';
                }
            }
        });

        // --- Drag and Drop Logic ---
        function startDrag(e) {
            if (e.target.tagName === 'TEXTAREA' || 
                e.target.classList.contains('delete-btn') || 
                e.target.classList.contains('connect-btn')) return;
            
            isDragging = true;
            activeNote = e.currentTarget;
            selectNote(activeNote);
            
            const rect = board.getBoundingClientRect();
            offsetX = e.clientX - rect.left - activeNote.offsetLeft;
            offsetY = e.clientY - rect.top - activeNote.offsetTop;
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            e.preventDefault();
        }

        function drag(e) {
            if (!isDragging || !activeNote) return;
            e.preventDefault();
            
            const rect = board.getBoundingClientRect();
            const newX = Math.max(0, Math.min(e.clientX - rect.left - offsetX, board.clientWidth - 220));
            const newY = Math.max(0, Math.min(e.clientY - rect.top - offsetY, board.clientHeight - 180));
            
            activeNote.style.left = `${newX}px`;
            activeNote.style.top = `${newY}px`;
            drawAllConnections();
        }

        async function stopDrag() {
            if (isDragging && activeNote && userId) {
                try {
                    const noteId = activeNote.id;
                    const newX = parseInt(activeNote.style.left, 10);
                    const newY = parseInt(activeNote.style.top, 10);
                    await updateNotePosition(noteId, newX, newY);
                } catch (error) {
                    console.error("Error updating position:", error);
                }
            }
            isDragging = false;
            activeNote = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // --- Connection Logic ---
        function startConnection(noteId) {
            isConnecting = true;
            startConnectionNodeId = noteId;
            board.style.cursor = 'crosshair';
        }

        async function handleNoteClick(e) {
            const clickedNote = e.currentTarget;
            if (isConnecting && startConnectionNodeId) {
                const endConnectionNodeId = clickedNote.id;
                if (startConnectionNodeId !== endConnectionNodeId) {
                    try {
                        const ids = [startConnectionNodeId, endConnectionNodeId].sort();
                        const connectionId = `${ids[0]}-${ids[1]}`;
                        await setDoc(doc(connectionsCollection, connectionId), { 
                            from: startConnectionNodeId, 
                            to: endConnectionNodeId 
                        });
                    } catch (error) {
                        console.error("Error creating connection:", error);
                    }
                }
                isConnecting = false;
                startConnectionNodeId = null;
                board.style.cursor = 'default';
            } else {
                selectNote(clickedNote);
            }
        }

        // --- Firestore Interactions ---
        async function updateNotePosition(id, x, y) {
            if (!userId) return;
            try {
                await setDoc(doc(notesCollection, id), { x, y }, { merge: true });
            } catch (error) {
                console.error("Error updating note position:", error);
            }
        }
        
        async function updateNoteContent(id, content) {
            if (!userId) return;
            try {
                await setDoc(doc(notesCollection, id), { content }, { merge: true });
            } catch (error) {
                console.error("Error updating note content:", error);
            }
        }

        async function deleteNote(id) {
            if (!userId) return;
            try {
                const q1 = query(connectionsCollection, where("from", "==", id));
                const q2 = query(connectionsCollection, where("to", "==", id));
                const [querySnapshot1, querySnapshot2] = await Promise.all([getDocs(q1), getDocs(q2)]);
                
                const deletePromises = [];
                querySnapshot1.forEach((doc) => deletePromises.push(deleteDoc(doc.ref)));
                querySnapshot2.forEach((doc) => deletePromises.push(deleteDoc(doc.ref)));
                await Promise.all(deletePromises);
                await deleteDoc(doc(notesCollection, id));
            } catch (error) {
                console.error("Error deleting note:", error);
            }
        }
        
        // --- Drag-to-Add New Note Logic ---
        let ghostNote = null;

        addNoteBtn.addEventListener('mousedown', (e) => {
            if (!userId) return;
            e.preventDefault();

            ghostNote = document.createElement('div');
            ghostNote.className = 'note';
            ghostNote.style.position = 'fixed';
            ghostNote.style.opacity = '0.7';
            ghostNote.style.pointerEvents = 'none';
            ghostNote.style.zIndex = '1000';
            ghostNote.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; font-size: 24px;">ðŸ“„</div>';
            document.body.appendChild(ghostNote);

            moveGhostNote(e);

            document.addEventListener('mousemove', moveGhostNote);
            document.addEventListener('mouseup', dropNote);
        });

        function moveGhostNote(e) {
            if (ghostNote) {
                ghostNote.style.left = `${e.clientX - 110}px`;
                ghostNote.style.top = `${e.clientY - 90}px`;
            }
        }

        async function dropNote(e) {
            document.removeEventListener('mousemove', moveGhostNote);
            document.removeEventListener('mouseup', dropNote);

            if (ghostNote) {
                const boardRect = board.getBoundingClientRect();
                if (
                    e.clientX >= boardRect.left && e.clientX <= boardRect.right &&
                    e.clientY >= boardRect.top && e.clientY <= boardRect.bottom
                ) {
                    try {
                        const noteId = `note-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                        const noteData = {
                            id: noteId,
                            x: Math.max(0, Math.min(e.clientX - boardRect.left - 110, board.clientWidth - 220)),
                            y: Math.max(0, Math.min(e.clientY - boardRect.top - 90, board.clientHeight - 180)),
                            content: '',
                            type: 'text',
                            owner: userId,
                            rotation: Math.random() * 8 - 4,
                            created: Date.now()
                        };
                        await setDoc(doc(notesCollection, noteId), noteData);
                    } catch (error) {
                        console.error("Error creating note:", error);
                    }
                }
                ghostNote.remove();
                ghostNote = null;
            }
        }

        // --- Real-time Listeners ---
        function initializeBoard() {
            resizeCanvas();
            listenForNotes();
            listenForConnections();
        }

        function listenForNotes() {
            if (unsubscribeNotes) unsubscribeNotes();
            
            unsubscribeNotes = onSnapshot(notesCollection, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    const noteData = { id: change.doc.id, ...change.doc.data() };
                    const noteId = noteData.id;

                    if (change.type === "added") {
                        if (!document.getElementById(noteId)) {
                            try {
                                const noteEl = await createNoteElement(noteData);
                                board.appendChild(noteEl);
                                notes.set(noteId, noteData);
                            } catch (error) {
                                console.error("Error creating note element:", error);
                            }
                        }
                    }
                    if (change.type === "modified") {
                        let noteEl = document.getElementById(noteId);
                        if (noteEl && noteEl !== activeNote) {
                            noteEl.style.left = `${noteData.x}px`;
                            noteEl.style.top = `${noteData.y}px`;
                            if (noteData.type === 'text') {
                                const textarea = noteEl.querySelector('textarea');
                                if (textarea && document.activeElement !== textarea) {
                                    textarea.value = noteData.content || '';
                                }
                            }
                        }
                        notes.set(noteId, noteData);
                    }
                    if (change.type === "removed") {
                        let noteEl = document.getElementById(noteId);
                        if (noteEl) {
                            noteEl.remove();
                            notes.delete(noteId);
                        }
                    }
                });
                drawAllConnections();
            }, (error) => {
                console.error("Notes listener error:", error);
                updateStatus('Notes Sync Error', 'error');
            });
        }
        
        function listenForConnections() {
            if (unsubscribeConnections) unsubscribeConnections();
            
            unsubscribeConnections = onSnapshot(connectionsCollection, (snapshot) => {
                connections.clear();
                snapshot.forEach(doc => {
                    connections.set(doc.id, doc.data());
                });
                drawAllConnections();
            }, (error) => {
                console.error("Connections listener error:", error);
            });
        }
        
        function drawAllConnections() {
            if (!ctx) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            connections.forEach(conn => {
                const fromNode = document.getElementById(conn.from);
                const toNode = document.getElementById(conn.to);

                if (fromNode && toNode) {
                    const boardRect = board.getBoundingClientRect();
                    const fromRect = fromNode.getBoundingClientRect();
                    const toRect = toNode.getBoundingClientRect();

                    const startX = fromRect.left - boardRect.left + fromRect.width / 2;
                    const startY = fromRect.top - boardRect.top + fromRect.height / 2;
                    const endX = toRect.left - boardRect.left + toRect.width / 2;
                    const endY = toRect.top - boardRect.top + toRect.height / 2;

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = '#c62828';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    ctx.stroke();
                }
            });
        }

        // --- Image Drop ---
        board.addEventListener('dragover', (e) => {
            e.preventDefault();
            board.style.filter = 'brightness(1.1)';
        });
        
        board.addEventListener('dragleave', () => {
            board.style.filter = 'brightness(1)';
        });
        
        board.addEventListener('drop', async (e) => {
            e.preventDefault();
            board.style.filter = 'brightness(1)';
            
            if (!userId) return;
            
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const noteId = `image-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                        const boardRect = board.getBoundingClientRect();
                        const noteData = {
                            id: noteId,
                            x: Math.max(0, Math.min(e.clientX - boardRect.left - 110, board.clientWidth - 220)),
                            y: Math.max(0, Math.min(e.clientY - boardRect.top - 90, board.clientHeight - 180)),
                            content: event.target.result,
                            type: 'image',
                            owner: userId,
                            rotation: Math.random() * 8 - 4,
                            created: Date.now()
                        };
                        await setDoc(doc(notesCollection, noteId), noteData);
                    } catch (error) {
                        console.error("Error creating image note:", error);
                    }
                };
                reader.readAsDataURL(file);
            }
        });

        // --- Keyboard Delete ---
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (document.activeElement.tagName !== 'TEXTAREA') {
                    const selectedNote = document.querySelector('.note.selected');
                    if (selectedNote) {
                        e.preventDefault();
                        deleteNote(selectedNote.id);
                    }
                }
            }
            if (e.key === 'Escape') {
                if (isConnecting) {
                    isConnecting = false;
                    startConnectionNodeId = null;
                    board.style.cursor = 'default';
                }
                selectNote(null);
            }
        });

        // --- Cleanup on page unload ---
        window.addEventListener('beforeunload', () => {
            if (unsubscribeNotes) unsubscribeNotes();
            if (unsubscribeConnections) unsubscribeConnections();
        });

    </script>
</body>
</html>
